//
// Zero Filter PTX Kernel - Writes zeros to output buffer
//

.version 8.0
.target sm_50
.address_size 64

.visible .entry zero_filter(
	.param .u64 zero_filter_param_0,  // input pointer (unused) -> uint32_t* input
	.param .u64 zero_filter_param_1,  // output pointer -> uint32_t* output  
	.param .u32 zero_filter_param_2,  // width -> uint32_t width
	.param .u32 zero_filter_param_3   // height -> uint32_t height
)
{
	// Readable register declarations (better than NVCC's numeric ranges)
	.reg .u32 %ctaid_x, %ctaid_y;          // blockIdx.x, blockIdx.y
	.reg .u32 %ntid_x, %ntid_y;            // blockDim.x, blockDim.y  
	.reg .u32 %tid_x, %tid_y;              // threadIdx.x, threadIdx.y
	.reg .u32 %x, %y;                      // global coordinates
	.reg .u32 %width, %height;             // kernel parameters
	.reg .u32 %idx;                        // linear index
	.reg .u64 %output_ptr;                 // output pointer
	.reg .u64 %offset;                     // byte offset
	.reg .u32 %zero;                       // zero value
	.reg .pred %p_x_bound, %p_y_bound, %p_exit;  // predicate registers

	// Load kernel parameters first (NVCC optimization)
	ld.param.u64 	%output_ptr, [zero_filter_param_1];  // output pointer
	ld.param.u32 	%width, [zero_filter_param_2];       // width
	ld.param.u32 	%height, [zero_filter_param_3];      // height
	
	// Calculate global coordinates efficiently
	mov.u32 	%ctaid_x, %ctaid.x;         // blockIdx.x
	mov.u32 	%ntid_x, %ntid.x;           // blockDim.x  
	mov.u32 	%tid_x, %tid.x;             // threadIdx.x
	mad.lo.s32 	%x, %ctaid_x, %ntid_x, %tid_x;  // x = blockIdx.x * blockDim.x + threadIdx.x
	
	mov.u32 	%ntid_y, %ntid.y;           // blockDim.y
	mov.u32 	%ctaid_y, %ctaid.y;         // blockIdx.y
	mov.u32 	%tid_y, %tid.y;             // threadIdx.y
	mad.lo.s32 	%y, %ctaid_y, %ntid_y, %tid_y;  // y = blockIdx.y * blockDim.y + threadIdx.y
	
	// Combined boundary checking (better branch prediction than sequential checks)
	setp.ge.u32 	%p_x_bound, %x, %width;     // p_x_bound = (x >= width)
	setp.ge.u32 	%p_y_bound, %y, %height;    // p_y_bound = (y >= height)  
	or.pred  	%p_exit, %p_x_bound, %p_y_bound;  // p_exit = (x >= width || y >= height)
	@%p_exit bra 	EXIT;                       // if (p_exit) goto EXIT - single branch!
	
	// Calculate linear index and address (NVCC-style with mul.wide)
	mad.lo.s32 	%idx, %y, %width, %x;       // idx = y * width + x
	mul.wide.u32 	%offset, %idx, 4;       // offset = idx * 4 (widen to 64-bit + multiply)
	add.s64 	%output_ptr, %output_ptr, %offset;  // output_ptr = output_ptr + offset
	
	// Write zero to output
	mov.u32 	%zero, 0;                   // zero = 0
	st.global.u32 	[%output_ptr], %zero;   // output[y * width + x] = 0

EXIT:
	ret;                                // return;
}
