//
// Sobel Edge Detection Filter - PTX Assembly with C Equivalents
//

//
// CUDA C function signature:
// __global__ void sobel_filter(unsigned char* input, unsigned char* output, int width, int height)
//

.version 8.8
.target sm_52
.address_size 64

.visible .entry sobel_filter(
	.param .u64 sobel_filter_param_0,    // unsigned char* input
	.param .u64 sobel_filter_param_1,    // unsigned char* output  
	.param .u32 sobel_filter_param_2,    // int width
	.param .u32 sobel_filter_param_3     // int height
)
{
	// Readable register declarations
	.reg .u32 %ctaid_x, %ctaid_y;          // blockIdx.x, blockIdx.y
	.reg .u32 %ntid_x, %ntid_y;            // blockDim.x, blockDim.y  
	.reg .u32 %tid_x, %tid_y;              // threadIdx.x, threadIdx.y
	.reg .u32 %x, %y;                      // global thread coordinates
	.reg .u32 %width, %height;             // image dimensions
	.reg .u32 %width_m1, %height_m1;       // width-1, height-1 for edge checks
	.reg .u32 %output_idx;                 // linear output index
	.reg .u64 %input_ptr, %output_ptr;     // base pointers
	.reg .u64 %pixel_addr;                 // current pixel address
	.reg .u32 %zero_val;                   // zero for border pixels
	
	// Address calculation temporaries
	.reg .u32 %top_idx, %mid_idx, %bot_idx;
	.reg .u64 %top_addr, %mid_addr, %bot_addr;
	
	// 3x3 neighborhood pixels
	.reg .u32 %p00, %p01, %p02;            // top row: left, center, right
	.reg .u32 %p10, %p12;                  // middle row: left, right (center unused)
	.reg .u32 %p20, %p21, %p22;            // bottom row: left, center, right
	
	// Sobel computations
	.reg .s32 %gx_tmp1, %gx_tmp2, %gx;     // X gradient calculations
	.reg .s32 %gy_tmp1, %gy_tmp2, %gy;     // Y gradient calculations
	.reg .u32 %gx_abs, %gy_abs;            // absolute values
	.reg .u32 %magnitude;                  // final magnitude
	
	// Predicate registers
	.reg .pred %p_x_bound, %p_y_bound, %p_out_bounds;
	.reg .pred %p_x_zero, %p_y_zero, %p_x_edge, %p_y_edge, %p_border;

	// Load kernel parameters
	ld.param.u64 	%input_ptr, [sobel_filter_param_0];
	ld.param.u64 	%output_ptr, [sobel_filter_param_1];
	ld.param.u32 	%width, [sobel_filter_param_2];
	ld.param.u32 	%height, [sobel_filter_param_3];

	// Calculate global thread coordinates
	mov.u32 	%ctaid_x, %ctaid.x;
	mov.u32 	%ntid_x, %ntid.x;
	mov.u32 	%tid_x, %tid.x;
	mad.lo.s32 	%x, %ctaid_x, %ntid_x, %tid_x;
	
	mov.u32 	%ctaid_y, %ctaid.y;
	mov.u32 	%ntid_y, %ntid.y;
	mov.u32 	%tid_y, %tid.y;
	mad.lo.s32 	%y, %ctaid_y, %ntid_y, %tid_y;

	// Boundary check
	setp.ge.s32 	%p_x_bound, %x, %width;
	setp.ge.s32 	%p_y_bound, %y, %height;
	or.pred  	%p_out_bounds, %p_x_bound, %p_y_bound;
	@%p_out_bounds bra 	EXIT;

	// Border pixel detection
	setp.eq.s32 	%p_x_zero, %x, 0;
	setp.eq.s32 	%p_y_zero, %y, 0;
	add.s32 	%width_m1, %width, -1;
	add.s32 	%height_m1, %height, -1;
	setp.eq.s32 	%p_x_edge, %x, %width_m1;
	setp.eq.s32 	%p_y_edge, %y, %height_m1;
	or.pred  	%p_border, %p_x_zero, %p_y_zero;
	or.pred  	%p_border, %p_border, %p_x_edge;
	or.pred  	%p_border, %p_border, %p_y_edge;

	// Calculate output address
	mad.lo.s32 	%output_idx, %y, %width, %x;
	cvt.s64.s32 	%pixel_addr, %output_idx;
	cvta.to.global.u64 	%output_ptr, %output_ptr;
	add.s64 	%pixel_addr, %output_ptr, %pixel_addr;

	@%p_border bra 	BORDER_PIXEL;
	bra.uni 	SOBEL_FILTER;

BORDER_PIXEL:
	mov.u32 	%zero_val, 0;
	st.global.u8 	[%pixel_addr], %zero_val;
	bra.uni 	EXIT;

SOBEL_FILTER:
	// Load 3x3 neighborhood
	cvta.to.global.u64 	%input_ptr, %input_ptr;
	
	// Top row (y-1)
	add.s32 	%top_idx, %y, -1;
	mad.lo.s32 	%top_idx, %top_idx, %width, %x;
	cvt.s64.s32 	%top_addr, %top_idx;
	add.s64 	%top_addr, %input_ptr, %top_addr;
	ld.global.u8 	%p00, [%top_addr+-1];    // top-left
	ld.global.u8 	%p01, [%top_addr];       // top-center
	ld.global.u8 	%p02, [%top_addr+1];     // top-right
	
	// Middle row (y)
	mad.lo.s32 	%mid_idx, %y, %width, %x;
	cvt.s64.s32 	%mid_addr, %mid_idx;
	add.s64 	%mid_addr, %input_ptr, %mid_addr;
	ld.global.u8 	%p10, [%mid_addr+-1];    // middle-left
	ld.global.u8 	%p12, [%mid_addr+1];     // middle-right
	
	// Bottom row (y+1)
	add.s32 	%bot_idx, %y, 1;
	mad.lo.s32 	%bot_idx, %bot_idx, %width, %x;
	cvt.s64.s32 	%bot_addr, %bot_idx;
	add.s64 	%bot_addr, %input_ptr, %bot_addr;
	ld.global.u8 	%p20, [%bot_addr+-1];    // bottom-left
	ld.global.u8 	%p21, [%bot_addr];       // bottom-center
	ld.global.u8 	%p22, [%bot_addr+1];     // bottom-right

	// Sobel X: [[-1,0,1],[-2,0,2],[-1,0,1]]
	// gx = (p02 + 2*p12 + p22) - (p00 + 2*p10 + p20)
	shl.b32 	%gx_tmp1, %p12, 1;           // 2*p12
	add.s32 	%gx_tmp1, %gx_tmp1, %p02;    // p02 + 2*p12
	add.s32 	%gx_tmp1, %gx_tmp1, %p22;    // p02 + 2*p12 + p22
	
	shl.b32 	%gx_tmp2, %p10, 1;           // 2*p10
	add.s32 	%gx_tmp2, %gx_tmp2, %p00;    // p00 + 2*p10
	add.s32 	%gx_tmp2, %gx_tmp2, %p20;    // p00 + 2*p10 + p20
	
	sub.s32 	%gx, %gx_tmp1, %gx_tmp2;     // gx = right - left

	// Sobel Y: [[-1,-2,-1],[0,0,0],[1,2,1]]
	// gy = (p20 + 2*p21 + p22) - (p00 + 2*p01 + p02)
	shl.b32 	%gy_tmp1, %p21, 1;           // 2*p21
	add.s32 	%gy_tmp1, %gy_tmp1, %p20;    // p20 + 2*p21
	add.s32 	%gy_tmp1, %gy_tmp1, %p22;    // p20 + 2*p21 + p22
	
	shl.b32 	%gy_tmp2, %p01, 1;           // 2*p01
	add.s32 	%gy_tmp2, %gy_tmp2, %p00;    // p00 + 2*p01
	add.s32 	%gy_tmp2, %gy_tmp2, %p02;    // p00 + 2*p01 + p02
	
	sub.s32 	%gy, %gy_tmp1, %gy_tmp2;     // gy = bottom - top

	// Calculate magnitude = |gx| + |gy|
	abs.s32 	%gx_abs, %gx;
	abs.s32 	%gy_abs, %gy;
	add.s32 	%magnitude, %gx_abs, %gy_abs;

	// Clamp to [0, 255]
	min.s32 	%magnitude, %magnitude, 255;

	// Store result
	st.global.u8 	[%pixel_addr], %magnitude;

EXIT:
	ret;
}

/*
 * Sobel Edge Detection Algorithm:
 * 1. Calculate thread coordinates and check bounds
 * 2. Set border pixels to 0 (black edges)
 * 3. For interior pixels:
 *    - Load 3x3 neighborhood
 *    - Apply Sobel X and Y kernels
 *    - Calculate gradient magnitude |gx| + |gy|
 *    - Clamp to [0,255] and store result
 */